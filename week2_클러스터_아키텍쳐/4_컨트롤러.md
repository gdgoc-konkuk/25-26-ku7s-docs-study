# 4. 컨트롤러

*컨트롤 루프* 는 시스템 상태를 조절하는 종료되지 않는 루프 -> 실내 온도 조절기(보일러, 에어컨)

쿠버네티스에서 컨트롤러는 클러스터의 상태를 관찰 한 다음, 필요한 경우에 생성 또는 변경을 요청하는 컨트롤 루프이다. 각 컨트롤러는 현재 클러스터 상태를 **의도한 상태에 가깝게 이동**한다.

## 4.1. 컨트롤러 패턴

>[!note] 컨트롤러 오브젝트는....
>의도한 상태를 표현하는 **사양 필드**를 가지고 있다. 이를 통해 현재 상태를 의도한 상태에 가깝게 만드는 역할을 한다. 컨트롤러는 스스로 작업을 수행할 수 있다. 쿠버네티스에서는 **컨트롤러가 API 서버로** 유용한 부수적인 효과가 있는 메시지를 발송한다.

### 4.1.2. API 서버를 통한 제어
잡(Job) 컨트롤러는 쿠버네티스 내장 컨트롤러의 예시이다. 내장 컨트롤러는 클러스터 API 서버와 상호작용하며 상태를 관리한다.(잡(Job)은 1개 이상의 파드를 실행하고, 작업을 수행한 다음 중지하는 **쿠버네티스 리소스**)
잡 컨트롤러가 새로운 작업을 확인하면, 클러스터 어딘가에서 노드 집합의 kubelet이 작업을 수행하기에 적합한 수의 파드를 실행하게 한다. 잡 컨트롤러는 어떤 파드 또는 컨테이너를 **스스로 실행하지 않는**다. 대신, 잡 컨트롤러는 API 서버에 **파드를 생성하거나 삭제하도록 지시**한다.

새 잡을 생성하고 나면, 의도한 상태는 해당 잡을 완료하는 것이 된다. 또한, 컨트롤러는 오브젝트의 설정을 업데이트 한다. 
예: 잡을 위한 작업이 종료된 경우, 잡 컨트롤러는 잡 오브젝트가 `Finished` 로 표시되도록 업데이트한다.

### 4.1.3. 직접 제어
#### 기본 개념
**직접 제어**란 쿠버네티스 컨트롤러가 단순히 클러스터 내부의 리소스만 관리하는 것이 아니라, **클러스터 외부의 실제 인프라를 직접 조작**하는 것을 말한다.

#### 왜 필요한가?

예를 들어, 클러스터에 **새로운 노드(서버)**가 필요한 상황:

- 쿠버네티스만으로는 물리 서버나 클라우드 인스턴스를 직접 만들 수 없습니다
- 그러려면 **클러스터 외부의 시스템(클라우드 제공자 API, 데이터센터 관리 시스템 등)과 통신**해야 합니다

#### 작동 방식

```
1️⃣ 의도한 상태 읽기 → API 서버에서 "이 정도의 노드가 필요해"라는 정보를 확인 
2️⃣ 외부 시스템과 통신 → AWS/GCP 등에 "새 인스턴스를 만들어줘" 요청 
3️⃣ 상태 보고 → API 서버에 "인스턴스 생성 완료!" 결과를 다시 등록
```


컨트롤러의 강력함은 **이런 개별 루프들이 독립적으로 동작하면서도 API 서버를 통해 서로 협력**한다는 것.

> [!IMPORTANT]  
> 클러스터의 컨트롤러가 실행 중이고 유용한 변경을 수행할 수 있는 한, **전체 상태가 안정적인지 아닌지는 중요하지 않다**.


## 4.2. 컨트롤러 디자인 원리

쿠버네티스는 **"한 가지 일을 잘하는 여러 개의 작은 컨트롤러"** 방식을 채택한다. 즉, 모든 기능을 하나에 담는 거대한 시스템 대신, **역할별로 분리된 컨트롤러들**이 협력하는 구조이다.

### 4.2.1. 구체적인 예시: Job 컨트롤러

```
Job 컨트롤러의 역할:

📋 입력 (의도한 상태)
  └─ Job 오브젝트를 관찰
     "3개의 작업을 병렬로 실행해야 한다"

🔧 작업 (상태 변경)
  └─ Pod를 생성
     → Pod가 실제 작업을 실행

📊 모니터링 (현재 상태 확인)
  └─ Pod 오브젝트를 추적
     "작업이 완료됐나?"
     "실패했나?"
```

**중요한 점:** Job 컨트롤러는 Pod를 **생성**하지만, Job 자체는 **다른 누군가가 생성**합니다.

### 4.2.2. 왜 이렇게 설계했나?

#### 1️⃣ 단순성과 유지보수성

```
❌ 나쁜 방식 (모놀리식)
Job 관리 + Pod 관리 + Volume 관리 + Network 관리 
→ 모두 한곳에 혼재 (복잡하고 유지보수 어려움)

✅ 좋은 방식 (분산)
Job 컨트롤러 | Pod 컨트롤러 | Volume 컨트롤러 | Network 컨트롤러
→ 각각 독립적 (단순하고 이해하기 쉬움)
```

#### 2️⃣ 장애 격리 (Fault Isolation)

가장 중요한 이유입니다:

```
컨트롤러 A가 실패하면?

모놀리식 구조:
  컨트롤러 A 충돌 → 전체 시스템 마비 💥

분산 구조:
  컨트롤러 A 충돌 →A만 재시작
                    B, C, D는 계속 작동 ✅
```

>[!important]
**쿠버네티스의 철학:** "컨트롤러는 언제든 실패할 수 있다. 그래서 **실패해도 괜찮도록 설계**했다."

#### 3️⃣ 확장성 (Scalability)

새로운 기능을 추가할 때:
기존 컨트롤러들에 영향 없이
새로운 컨트롤러만 추가하면 됨


### 4.2.3. 컨트롤러 간 협력 방식 예시

```
시나리오: Job을 생성하면?

1️⃣ Job 컨트롤러
   "새 Job이 생겼네 → Pod를 3개 만들어야겠다"

2️⃣ Pod 컨트롤러  
   "새 Pod이 생겼네 → Node에 스케줄링해야겠다"

3️⃣ Node 컨트롤러
   "Pod을 스케줄링했네 → 리소스 할당해야겠다"

4️⃣ Network 컨트롤러
   "Pod이 할당됐네 → 네트워크 연결해야겠다"

모든 컨트롤러가 API 서버를 통해 관찰하고 협력!
```

