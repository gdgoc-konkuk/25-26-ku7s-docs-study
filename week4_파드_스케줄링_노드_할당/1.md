## 1. 쿠버네티스 스케줄러란?

쿠버네티스 스케줄러는 **"어느 노드에 파드를 배치할지 결정하는 관리자"** 

**실생활 비유:** 학교에서 학생들을 교실에 배치하는 것과 유사. 스케줄러는:

- 각 교실(노드)의 자리(리소스) 확인
- 학생(파드)의 요구사항 확인
- 가장 적합한 교실에 배치

**작동 과정:**
1. 사용자가 파드 생성 요청
2. 스케줄러가 모든 노드를 검토
3. 필터링: 요구사항을 만족하는 노드만 선택
4. 점수 계산: 각 노드에 점수 부여
5. 가장 높은 점수의 노드에 파드 할당

## 2. 노드에 파드 할당하기

### 방법 1: nodeSelector (가장 간단)

특정 라벨을 가진 노드에만 배치.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx
  nodeSelector:
    disktype: ssd  # SSD 디스크를 가진 노드에만 배치
```

**실제 사용 예시:**

```bash
# 1. 노드에 라벨 추가
kubectl label nodes worker-1 disktype=ssd

# 2. 파드 생성 시 해당 노드에만 배치됨
kubectl apply -f pod.yaml
```

### 방법 2: nodeAffinity (더 유연함)

필수 조건과 선호 조건을 지정.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  affinity:
    nodeAffinity:
      # 필수 조건: 반드시 만족해야 함
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: disktype
            operator: In
            values:
            - ssd
      # 선호 조건: 가능하면 만족하는 것이 좋음
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1
        preference:
          matchExpressions:
          - key: region
            operator: In
            values:
            - seoul
  containers:
  - name: nginx
    image: nginx
```

**실생활 비유:**

- `required`: "무조건 에어컨이 있는 방에 배치해줘" (없으면 배치 안 됨)
- `preferred`: "가능하면 창문이 있는 방이 좋아" (없어도 배치됨)

### 방법 3: nodeName (직접 지정)

특정 노드를 직접 지정합니다. 스케줄러를 우회하므로 주의해서 사용.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  nodeName: worker-1  # worker-1 노드에 직접 배치
  containers:
  - name: nginx
    image: nginx
```

**주의사항:**

- 지정한 노드가 없거나 리소스가 부족하면 파드가 실행되지 않음
- 일반적으로 권장되지 않는 방법

## 3. 파드 오버헤드

파드 오버헤드는 **"컨테이너 실행을 위해 추가로 필요한 리소스"** .

**실생활 비유:** 식당에서 요리(컨테이너)를 만들 때:

- 요리 재료(컨테이너 리소스): 500g
- 그릇, 접시, 조리 도구(오버헤드): 120g
- 실제 필요한 총량: 620g

### RuntimeClass로 오버헤드 정의

```yaml
# RuntimeClass 정의
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: kata-fc
handler: kata-fc
overhead:
  podFixed:
    memory: "120Mi"  # 추가 메모리
    cpu: "250m"      # 추가 CPU
```

### 파드에서 RuntimeClass 사용

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
spec:
  runtimeClassName: kata-fc  # RuntimeClass 지정
  containers:
  - name: nginx
    image: nginx
    resources:
      limits:
        cpu: 1500m
        memory: 100Mi
```

**실제 리소스 계산:**

- 컨테이너 요청: CPU 1500m, Memory 100Mi
- 오버헤드: CPU 250m, Memory 120Mi
- **총 필요량: CPU 1750m, Memory 220Mi**

스케줄러는 총 필요량을 고려해서 노드에 배치.

```bash
# 오버헤드 확인
kubectl describe node | grep test-pod -B2
```

## 4. 파드 스케줄링 준비성 (Scheduling Readiness)

**"아직 스케줄하지 마세요!"** 라는 신호를 보내는 기능.

**실생활 비유:** 호텔 예약 시:

- 예약은 했지만 아직 방 준비가 안 됨 (schedulingGates 있음)
- 청소와 정리가 완료되면 체크인 가능 (schedulingGates 제거)

### Scheduling Gates 사용 예시

```yaml
# 1. 스케줄링이 차단된 파드 생성
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
spec:
  schedulingGates:
  - name: example.com/waiting-for-data    # 데이터 준비 대기
  - name: example.com/waiting-for-approval  # 승인 대기
  containers:
  - name: nginx
    image: nginx
```

**파드 상태 확인:**

```bash
kubectl get pod test-pod
# NAME       READY   STATUS              RESTARTS   AGE
# test-pod   0/1     SchedulingGated     0          10s
```

### Scheduling Gates 제거

준비가 완료되면 gates를 제거:

```yaml
# 2. gates 없이 다시 적용하면 스케줄링 시작
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
spec:
  # schedulingGates 필드 제거됨
  containers:
  - name: nginx
    image: nginx
```

```bash
kubectl apply -f pod.yaml

# 파드가 이제 스케줄링되고 실행됨
kubectl get pod test-pod -o wide
# NAME       READY   STATUS    RESTARTS   AGE   IP            NODE
# test-pod   1/1     Running   0          20s   10.244.1.5    worker-1
```

### 실제 사용 사례

**예시: 프로젝트에서의 활용**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: ai-processing-pod
spec:
  schedulingGates:
  - name: hub.ai.com/payment-verified    # 결제 확인 대기
  - name: hub.ai.com/quota-available     # 할당량 확인 대기
  containers:
  - name: ai-worker
    image: ai-worker:latest
    resources:
      requests:
        cpu: 2000m
        memory: 4Gi
```

**워크플로우:**

1. 사용자가 AI 작업 요청
2. 파드가 생성되지만 스케줄링 차단됨
3. 결제 시스템이 코인 차감 확인
4. 할당량 시스템이 사용 가능 여부 확인
5. 모든 조건 만족 시 gates 제거
6. 파드가 노드에 스케줄링되고 실행됨

이렇게 하면 리소스를 낭비하지 않고 **필요한 조건이 모두 만족될 때만 파드를 실행**