한 네임스페이스 안에서, 컨테이너(또는 파드)가 사용할 수 있는 리소스의 최소와 최대 범위를 지정하는 정책

> **네임스페이스**: 단일 클러스터 내에서 리소스 그룹 격리 매커니즘을 제공
>
> ![alt text](./img/image0_1.png)
>
> ### 리소스 요청(request)과 제한(limit)의 개념
>
> - Request: 이 컨테이너가 최소한 이만큼은 꼭 필요하다고 알려주는 의미
> - Limit: 이 이상은 절대 사용하지 못함

- 왜?
  - 문제: 기본적으로 쿠버네티스에서는 컨테이너가 CPU와 메모리를 무제한으로 사용 가능 → 하나의 pod가 너무 많은 리소스를 사용할 경우 다른 pod가 느려지거나 죽음
    네임스페이스 안에서 컨테이너가 사용할 수 있는 리소스의 범위를 제한함으로써 이러한 현상을 막음
- 하는 일

  - 최소/최대 사용량 지정: 한 컨테이너(Pod)가 사용할 수 있는 CPU, 메모리의 최소와 최대 지정
  - 스토리지 제한: PVC(PersistentVolumeClaim)의 최소, 최대 용량 제한

    > PVC(PersistentVolumeClaim): 스토리지(저장공간)을 요청하는 객체
    >
    > - Pod가 사라져도 남는 스토리지를 요청하는 문서

  - Request와 Limit의 비율: limit/request 비율을 제한해 과도한 설정 방지
  - Default 설정: 기본값을 미리 설정

### 동작 원리

네임스페이스마다 LimitRange 오브젝트를 만들어 작동 → 그 네임스페이스 안에 pod들은 모두 그 규칙의 영향을 받음

- LimitRange 오브젝트 이름은 유효한 DNS 서브도메인 형식을 따름
- 이미 실행 중인 파드에는 적용되지 않음
- 2개 이상의 LimitRange 오브젝트가 존재할 경우 비결정저으로 작동

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: limit-range-demo
  namespace: dev
spec:
  limits:
    - type: Container
      max:
        cpu: "2"
        memory: "1Gi"
      min:
        cpu: "100m"
        memory: "100Mi"
      default:
        cpu: "500m"
        memory: "200Mi"
      defaultRequest:
        cpu: "200m"
        memory: "100Mi"
```

- 컨테이너는 최소 100m CPU, 최대 2개 사용 가능
- request를 작성하지 않으면 default 값으로 200m CPU/100Mi 메모리 설정
- limit을 작성하지 않으면 default 값으로 500m CPU/200Mi 메모리 설정

### 동작 프로세스

1. 관리자가 네임스페이스에 LimitRange 생성

   위처럼 yaml 파일로 만들어서 apply

2. 사용자가 Pod나 PVC 같은 리소스 생성 시도

   쿠버네티스 API 서버가 네임스페이스 안에서 새 파드가 띄워지면, 이 리소스가 LimitRange 규칙을 어기는지 체크

3. LimitRange Admission Controller 작동

   API 서버로 들어오는 요청을 검사하는 보안 게이트

4. 제약 위반 시 API 요청 거부

   규칙을 어기면 403 Forbidden 에러를 반환

   LimitRange에서 정의된 범위를 넘는 요청은 리소스 생성 자체가 거부

5. 유효한 경우 정상 생성

   Pod에 request/limit 값이 반영되어 클러스터에 배포

### 문제: LimitRange 기본값 불일치

Pod 생성 요청이 limit 범위를 벗어났을 경우

- Example
  ```yaml
  apiVersion: v1
  kind: LimitRange
  metadata:
    name: cpu-resource-constraint
  spec:
    limits:
      - default:
          cpu: 500m
        defaultRequest:
          cpu: 500m
        max:
          cpu: "1"
        min:
          cpu: 100m
  ```
  default가 500m이고, defaultRequestrh 500m일 때,
  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: example-conflict-with-limitrange-cpu
  spec:
    containers:
      - name: demo
        image: registry.k8s.io/pause:2.0
        resources:
          requests:
            cpu: 700m
  ```
  위와 같은 pod가 생성되면 limit이 명시되지 않았기 때문에 `request.cpu: 700m`이고 `limits.cpu:500`이 됨
  해당 pod는 생성되지만 스케줄링되지 않고, 오류 발생
  ```
  Pod "example-conflict-with-limitrange-cpu" is invalid: spec.containers[0].resources.requests: Invalid value: "700m": must be less than or equal to cpu limit
  ```
  아래와 같은 요청이 옳은 요청
  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: example-no-conflict-with-limitrange-cpu
  spec:
    containers:
      - name: demo
        image: registry.k8s.io/pause:2.0
        resources:
          requests:
            cpu: 700m
          limits:
            cpu: 700m
  ```

### 실제 정책 구성 예시

| 정책 항목       | 설명                                                                                      |
| --------------- | ----------------------------------------------------------------------------------------- |
| **CPU 제한**    | CPU 최대 제한 500m, 최소 요청 100m 설정                                                   |
| **메모리 제한** | 메모리 최대 600Mi, 최소 요청 200Mi 설정                                                   |
| **기본값 정의** | 요청·제한이 없는 컨테이너는 자동으로 CPU 150m, 메모리 300Mi 적용                          |
| **주의점**      | 네임스페이스의 전체 자원(ResourceQuota)이 파드들의 합보다 작으면Conflict 발생 → 생성 불가 |
