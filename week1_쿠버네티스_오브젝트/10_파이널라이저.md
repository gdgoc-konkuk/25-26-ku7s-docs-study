### 파이널라이저

---

<aside>

쉽게 비유하자면, **“오브젝트 철거 전 반드시 수행해야 할 안전점검 목록”** 이라고 할 수 있다.

</aside>

<br>

우리가 어떤 오브젝트(예: 파드, PV)에 대해 삭제 명령(`kubectl delete`)을 내렸다고 해보자.

쿠버네티스는 이 '안전점검 목록'에 항목이 남아있으면 즉시 철거(삭제)하지 않고 기다린다.

- 그리고 해당 점검 항목을 담당하는 컨트롤러에게 "이거 삭제될 거니까, 네가 맡은 뒷정리(clean up) 좀 해줘!" 라고 알려주는 역할을 한다.

이 뒷정리 작업은 오브젝트와 연결된 외부 클라우드 자원(디스크, 로드밸런서 등)을 삭제하는 것 등이 될 수 있다.

<br>

파이널라이저가 리소스들의 [가비지 컬렉션](https://kubernetes.io/ko/docs/concepts/architecture/garbage-collection/)을 제어하도록 사용할 수 있다.

- 예로, 하나의 파이널라이저를 컨트롤러가 대상 리소스를 삭제하기 전에 연관된 리소스들 또는 인프라를 정리하도록 정의할 수 있다.

<br>

파이널라이저(Finalizer)를 사용하면 리소스를 삭제하기 전 특정 정리 작업을 수행하도록 [컨트롤러(Controller)](https://kubernetes.io/ko/docs/concepts/architecture/controller/)에 경고하여 리소스의 [가비지(Garbage) 수집](https://kubernetes.io/ko/docs/concepts/architecture/garbage-collection/)을 제어할 수 있다.

<br>

파이널라이저는 보통 실행할 코드를 지정하지 않는다. 대신 파이널라이저는 일반적으로 어노테이션과 비슷하게 특정 리소스에 대한 키들의 목록이다.

이 '키'를 보고 어떤 컨트롤러가 "아, 이건 내 담당이구나!"라고 인지하고 자신의 임무(뒷정리 로직)를 수행하게 되는 것이다.

일부 파이널라이저는 쿠버네티스가 자동으로 지정하지만, 사용자가 직접 지정할 수도 있다.

---

### 파이널라이저의 작동 방식

1. **삭제 요청:** 우리가 오브젝트 A(파이널라이저가 있음)에 대해 삭제 명령을 내린다.
2. **삭제 보류 및 '삭제 표식' 부착:** API 서버는 `metadata.finalizers` 목록이 비어있지 않은 것을 확인하고, 오브젝트를 **즉시 삭제하지 않는다.** 대신, `metadata.deletionTimestamp` 필드에 현재 시간을 기록한다. 마치 "이 오브젝트는 곧 삭제될 운명이야" 라는 '사망 선고' 표식을 붙이는 것과 같다.
3. **`Terminating` 상태 돌입:** 이제 오브젝트의 상태(Status)는 `Terminating`(종료 중)으로 표시된다. 오브젝트는 아직 클러스터에 존재하지만, 삭제 절차를 밟고 있다.
4. **컨트롤러의 뒷정리 작업:** 해당 파이널라이저를 담당하는 컨트롤러가 `deletionTimestamp`가 찍힌 것을 감지하고, 자신이 해야 할 뒷정리 작업(예: 외부 리소스 정리)을 시작한다.
5. **'안전점검 목록'에서 항목 제거:** 뒷정리 작업이 성공적으로 끝나면, 컨트롤러는 오브젝트의 `metadata.finalizers` 목록에서 자신의 파이널라이저 키를 **스스로 제거한다**.
6. **최종 삭제:** `metadata.finalizers` 목록이 **완전히 비워지면**, 쿠버네티스는 '사망 선고'(`deletionTimestamp`)도 있고, '안전점검 목록'도 비었으니 이제 진짜로 삭제해도 되겠다고 판단하고, 오브젝트를 영구적으로 제거한다.

<br>

파이널라이저의 일반적인 예로는 `퍼시스턴트 볼륨(Persistent Volume)` 오브젝트가 실수로 삭제되는 것을 방지하는 `kubernetes.io/pv-protection`가 있다. (그렇다고 한다)

- `퍼시스턴트 볼륨` 오브젝트를 사용 중일 때 쿠버네티스는 `pv-protection` 파이널라이저를 추가한다.
- `퍼시스턴트 볼륨`을 삭제하려 하면 `Terminating` 상태가 되지만 파이널라이저가 존재하기 때문에 컨트롤러가 삭제할 수 없다.
- 파드가 `퍼시스턴트 볼륨`의 사용을 중지하면 쿠버네티스가 `pv-protection` 파이널라이저를 해제하고 컨트롤러는 볼륨을 삭제한다.

---

### 소유자 참조, 레이블, 파이널라이저

레이블, 소유자 참조, 파이널라이저의 개념이 얽혀 문제를 일으킬 수도 있다.

**예를 들어**

**'부모 A'** 와 **'자식 B'** 가 '가족 관계 증명서'(소유자 참조)로 묶여 있다고 가정하자.

우리가 '부모 A'를 삭제하면, 쿠버네티스는 '자식 B'부터 먼저 정리하려고 한다.

그런데 만약 '자식 B'에게 어떤 문제로 인해 **해결되지 않는 '필수 확인 목록'(파이널라이저)이 남아있다면** 어떻게 될까?

- '자식 B'는 삭제되지 못하고 계속 `Terminating` 상태에 갇히게 된다.
- 쿠버네티스는 자식이 모두 정리되기를 기다리기 때문에, '부모 A' 역시 영원히 삭제되지 못하고 똑같이 `Terminating` 상태에 머무르게 된다.

따라서 어떤 오브젝트가 삭제되지 않고 멈춰있다면, 문서의 조언처럼 해당 오브젝트와 그 자식 오브젝트들의 파이널라이저와 소유자 참조 관계를 함께 살펴보는 것이 문제 해결의 열쇠가 될 수 있다.

<aside>

---

**참고**

오브젝트가 `Terminating` 상태에 갇혔다고 절대로 파이널라이저를 강제로 수동 삭제하지 말자.

- **일반적으로 파이널라이저는 특정한 목적으로 가지고 리소스에 추가되므로, 강제로 제거하면 클러스터에 문제가 발생할 수 있다.**
- **파이널라이저의 목적을 이해하고 다른 방법(예를 들어, 일부 종속 객체를 수동으로 정리하는 것)으로 수행될 때만 수행해야 한다.**
</aside>
