## 레플리케이션 컨트롤러

레플리케이션 컨트롤러? 보다 ReplicaSet을 구성하는 Deployment가 현재 권장하는 레플리케이션 설정 방법이다.

그래도 구버전의 기능을 아는 것이 현재의 Deployment 동작 방식을 이해하는 데 도움이 될 수 있으니 알아보자.

---

1. **레플리케이션 컨트롤러란?**

- 레플리케이션 컨트롤러(RC)는 언제든지 **지정된 수의 파드 레플리카(복제본)가 실행 중임**을 보장한다.
- 파드가 실패, 삭제, 종료되면 **자동으로 교체된다**.
- 이는 커널 업그레이드 같은 유지보수 작업 후에도 마찬가지다.
- 따라서 단 하나의 파드만 필요하더라도 RC를 사용하는 것이 좋습니다.

---

2. **예제**

   ```yaml
   apiVersion: v1
   kind: ReplicationController
   metadata:
   name: nginx
   spec:
   replicas: 3
   selector:
       app: nginx
   template:
       metadata:
       name: nginx
       labels:
           app: nginx
       spec:
       containers:
       - name: nginx
           image: nginx
           ports:
           - containerPort: 80

   ```

- 제공된 YAML 예제는 `nginx` 레플리케이션 컨트롤러를 생성하여 3개의 `nginx` 파드 복제본을 실행한다.

- `kubectl describe rc/nginx` 명령으로 상태를 보면 `Replicas: 3 current / 3 desired` (현재 3명 / 목표 3명) 상태와, 생성된 파드 목록을 볼 수 있다.

---

3. **레플리케이션 컨트롤러의 Spec 작성**

- 다른 모든 쿠버네티스 컨피그와 마찬가지로 레플리케이션 컨트롤러는 `apiVersion`, `kind`, `metadata` 와 같은 필드가 필요
- 레플리케이션 컨트롤러 오브젝트의 이름은 유효한 [DNS 서브도메인 이름](https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/names/#dns-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%A6%84)이어야 한다.
- **spec 설정**
  - `.spec.template` (파드 템플릿): RC `spec`의 유일한 필수 필드이며, 생성할 파드의 명세.
    - `restartPolicy`는 `Always`만 허용됩니다.
  - `.spec.selector` (레이블 셀렉터): RC가 **관리할 파드를 식별**하는 규칙
  - `.spec.selector`는 `.spec.template.metadata.labels`와 **반드시 일치해야** 한다. (채용할 직원의 이름표와 관리할 직원의 이름표가 같아야 합니다.)
  - `.spec.replicas`: 동시에 실행할 파드의 목표 개수

---

4. **레플리케이션 컨트롤러 사용하기**

- `kubectl delete`: RC와 RC가 관리하던 모든 파드를 삭제
- `kubectl delete --cascade=orphan`: RC만 삭제하고 파드들은 남겨둔다(고아 파드).
- **파드 격리:** 파드의 레이블을 변경하여 RC의 `selector`와 일치하지 않게 만들면, RC는 해당 파드를 관리 대상에서 제외한다.
  - 그리고 RC는 목표 레플리카 수를 맞추기 위해 **새 파드를 즉시 생성한다.**

---

5. **일반적인 사용법 패턴**

- **다시 스케줄하기**
  - 노드 실패 또는 파드 종료시 지정된 수의 파드가 존재하도록 보장하는 방법
- **스케일링**
  - `replicas` 필드를 업데이트하여, 수동으로 또는 오토 스케일링 제어 에이전트를 통해, 레플리카의 수를 늘리거나 줄인다.
- **롤링 업데이트**
  - 레플리케이션 컨트롤러는 파드를 하나씩 교체함으로써 서비스에 대한 롤링 업데이트를 쉽게 하도록 설계되었다.
  - 2개의 기둥이 있는 하노이탑마냥, 두 개의 RC를 생성하고 하나씩 스케일 업/다운하는 방식이다.
  - 매우 복잡하기 때문에 Deployment가 권장된다.
- **다수의 릴리스 트랙**
  - 카나리 배포를 의미하는 것 같다.
  - 10명의 직원이 필요한데
    - 9명은 "기존 매뉴얼"(RC 1, `track=stable`)로 일하게 하고
    - 1명은 "신규 매뉴얼"(RC 2, `track=canary`)로 일하게 하여 테스트하는 방식

---

6. **레플리케이션을 위한 프로그램 작성**

- RC에 의해 생성된 파드들은 **균일하고 의미상 동일하도록(stateless)** 설계 되었다.
  - 이는 스테이트리스(stateless) 서버에 적합하다.
- 만약 마스터 선출이나 작업 분배가 필요하다면, 파드에 정적/일회성 구성을 하는 **(안티패턴)** 대신, **동적 작업 할당 메커니즘**(예: RabbitMQ 작업 큐)을 사용해야 한다.
- 또한, 파드의 CPU나 메모리 사양을 조절(수직 자동 크기 조정)하는 것은 RC의 책임이 아니며, 다른 컨트롤러가 수행해야 한다.

---

7. **레플리케이션 컨트롤러의 책임**

- RC는 **의도한 수의 파드가 레이블 셀렉터와 일치하는지만** 확인한다.
  - 즉, 스케줄링 정책, 기한 완료 등 다른 기능을 수행하지 않는다.

---

8. **레플리케이션 컨트롤러의 대안**

- RC는 이제 잘 쓰이지 않는다. 더 좋은 도구들이 있다.

  - **레플리카셋**
    - RC와 거의 똑같지만, 직원을 찾는 방법(`selector`)이 더 강력해졌다.
    - RC는 `app=nginx`처럼 단순한 이름표만 가능했지만
    - RS는 "tier=frontend 이면서 version != 1.0" 같은 복잡한 조건 검색이 가능하다.
  - **디플로이먼트 (권장됨)**
    - `ReplicaSet`을 관리하는 **상위 수준의 API 오브젝트**
    - 선언적 롤링 업데이트와 롤백 기능을 제공하므로 **현재 가장 권장되는 방식**
  - **베어 파드**
    - 노드 오류 시 파드가 자동으로 교체되지 않으므로, 신뢰성이 필요하면 RC (또는 Deployment)를 써야 한다.
  - **잡**
    - **종료될 것으로 예상되는 파드**(배치 작업)에 사용
    - RC/Deployment는 절대 종료되면 안 되는 파드에 사용
  - **데몬셋**
    - **모든 노드(또는 특정 노드)마다 1개씩** 실행되어야 하는 파드(로그 수집기 등)에 사용
