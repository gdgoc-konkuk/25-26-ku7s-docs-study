쿠버네티스에서 Stateless 애플리케이션을 자동으로 배포하고 관리하기 위한 리소스이다.

> **Stateless 애플리케이션**: 이전 요청의 상태 정보를 기억하지 않고, 각 요청을 독립적으로 처리하는 애플리케이션이다.
> → 이전 요청에 대한 정보를 가지지 않는다.

- **선언적 업데이트 방식**: 디플로이먼트를 정의해 관리한다.
- 주의할 점: 디플로이먼트가 생성한 레플리카셋은 직접 수정하면 안된다. → 디플로이먼트가 의도한 상태와 충돌 발생 가능
- **동작 방식**

  1. 새로운 레플리카셋 생성
  2. 해당 레플리카셋을 통해 파드들을 배포
  3. 점진적으로 이전 버전의 파드들을 종료하고, 새 버전으로 교체

     → 문제 발생 시 롤백으로 이전 버전으로 되돌린다.

## 유스케이스

디플로이먼트의 상황/시나리오이다. → 시스템을 어떻게 사용하는지 정리해 둔 사용 목적과 예시

> 디플로이먼트가 사용자의 유스케이스에 나와 있는 정상적인 범위에 포함되지 않는다면, 쿠버네티스 리포지토리에 이슈를 올려야 한다.

- 일반적인 유스케이스의 예시
  - 디플로이먼트를 생성해 레플리카셋을 롤아웃 → 배포
  - PodTemplateSpec을 업데이트해 새 버전 배포
  - 문제가 생기면 이전 버전으로 롤백
  - 트래픽이 많을 때 스케일 업
  - 롤아웃 일시 중지 → 수정 후 재개
  - 롤아웃이 막혔는지 상태 확인
  - 이전 레플리카셋 정리

## 디플로이먼트 생성

- 3개의 레플리카셋을 생성하는 디플로이먼트의 예시
  ```yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    labels:
      app: nginx
  spec:
    replicas: 3
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
          - name: nginx
            image: nginx:1.14.2
            ports:
              - containerPort: 80
  ```
  - 이름(`.metadata.name` 필드): nginx-deployment 디플로이먼트 생성
  - 복제된 파드의 개수(`.spec.replicas` 필드): 복제된 파드 3개를 만드는 레플리카셋을 새성
  - 생성된 레플리카셋이 관리할 파드를 찾아내는 방법(`.spec.selector` 필드): 어떤 파드를 관리할지 정의하는 부분 → 여기서는 파드 템플릿에 정의된 레이블을 선택
    - matchLabels: 간단한 key-value 라벨 조건
    - matchExpressions: 좀 더 복잡한 조건식을 작성 가능
  - `.spec.template` 필드
    - `.metadata.labels` 필드: 파드에 이름표를 붙이는 것
    - `.spec` 필드: 무엇을 실행할지를 정의

### **생성하는 방법**

1. 쿠버네티스 클러스터가 시작되고 실행 중인지 확인
2. 명령어를 통해 디플로이먼트 생성

   ```yaml
   kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
   ```

3. `kubectl get deployments`를 통해 디플로이먼트가 생성되었는지 확인

   ```yaml
   NAME               READY   UP-TO-DATE   AVAILABLE   AGE
   nginx-deployment   0/3     0            0           1s
   ```

   - READY: 실행 중이며 정상 상태인 파드수 / 원하는 파드 수
   - UP-TO-DATE: 의도한 상태로 업데이트된 파드
   - AVAILABLE: 실제로 사용자 요청을 처리할 수 있는 파드 수
   - AGE: 디플로이먼트가 만들어진 후 경과된 시간

4. `kubectl rollout status deployment/nginx-deployment`를 통해 롤아웃 상태를 확인

   ```
   Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
   deployment "nginx-deployment" successfully rolled out
   ```

5. 이후 `kubectl get deployment`를 다시 실행하면 아래처럼 상태가 의도한 상태로 업데이트된 것을 확인 가능

   ```
   NAME               READY   UP-TO-DATE   AVAILABLE   AGE
   nginx-deployment   3/3     3            3           18s
   ```

6. `kubectl get rs`를 통해 디플로이먼트로 생성된 레플리카셋을 확인 가능

   ```
   NAME                          DESIRED   CURRENT   READY   AGE
   nginx-deployment-75675f5897   3         3         3       18s
   ```

   - DESIRED: 디플로이먼트 생성 시 정의된 의도한 애플리케이션 레플리카의 수
   - CURRENT: 현재 실행 중인 레플리카의 수를 표시
   - READY: 실제로 사용자 요청을 처리할 수 있는 파드 수
   - AGE: 디플로이먼트가 만들어진 후 경과된 시간

   레플리카셋의 이름은 항상 [DEPLOYMENT_NAME]-[HASH] 형식이다.

7. `kubectl get pods --show-labels`를 통해 각 파드에 자동으로 생성된 레이블을 확인

   ```
   NAME                                READY     STATUS    RESTARTS   AGE       LABELS
   nginx-deployment-75675f5897-7ci7o   1/1       Running   0          18s       app=nginx,pod-template-hash=75675f5897
   nginx-deployment-75675f5897-kzszj   1/1       Running   0          18s       app=nginx,pod-template-hash=75675f5897
   nginx-deployment-75675f5897-qqcnn   1/1       Running   0          18s       app=nginx,pod-template-hash=75675f5897
   ```

### **주의 사항**

- 디플로이먼트 생성 시 파드 템플릿 레이블과 셀렉터를 반드시 명시해야 한다.
  → 내가 관리할 파드의 조건(`.spec.selector`)와 내가 만들 파드에 붙일 라벨(`.spec.template.metadata.labels`)이 일치해야 한다.
- 여러 종류의 컨트롤러(Deployment, StatefulSet, DaemonSet, ReplicaSet 등) 중 두 컨트롤러가 같은 레벨 셀렉터를 가지면 충돌이 발생한다.
  → 같은 레벨을 가진 파드를 동시에 관리하려고 할 때 문제 발생(쿠버네티스는 여기에 책임을 지지 않는다.)

### Pod-template-hash 테이블

디플로이먼트가 내부에서 자동으로 생성하는 레이블이다.

- 여러 롤링 업데이트(배포) 버전을 구분하기위해 고유한 pod-template-hash 값을 부여하고 이를 관리하기 위한 테이블이다.
  → 버전별로 다른 해시를 가지기 때문에 충돌이 발생하지 않음

> **롤링 업데이트**: 배포 과정의 한 방식으로 기존 파드를 한꺼번에 종료하지 않고, 조금씩 새 버전으로 교체하는 방식

-> 사용자가 변경해서는 안된다!

## 디플로이먼트 업데이트

- 디플로이먼트 롤아웃이 트리거되는 경우 → 디플로이먼트의 파드 템플릿이 변경된 경우
  - 템플릿의 레이블이나 컨테이너 이미지가 업데이트된 경우
  - 스케일링과 같은 업데이트는 트리거하지 말아야 함
    > **디플로이먼트 스케일링**: 실행 중인 파드의 개수를 늘리거나 줄이는 것

### 작동 방식

1. `nginx:1.14.2` 이미지 대신 `nginx:1.16.1` 이미지를 사용하도록 nginx 파드를 업데이트한다.

   ```
   kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1
   kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
   ...
   deployment.apps/nginx-deployment image updated
   ```

   `{deployment}/{업데이트가 이루어질 컨테이너} {새 이미지와 태그 값}` 형식을 가진다.

   혹은 디플로이먼트를 edit해서 사용한다.

   ```
   kubectl edit deployment/nginx-deployment
   ...
   deployment.apps/nginx-deployment edited
   ```

2. 롤아웃 상태를 보기 위해 명령어를 실행한다.

   ```
   kubectl rollout status deployment/nginx-deployment
   ...
   Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
   or
   deployment "nginx-deployment" successfully rolled out
   ```

3. 롤아웃이 성공하면 `kubectl get deployments`를 실행해서 디플로이먼트를 확인한다.

   ```
   NAME               READY   UP-TO-DATE   AVAILABLE   AGE
   nginx-deployment   3/3     3            3           36s
   ```

   `kubectl get rs`를 통해 새 레플리카셋을 생성해서 파드를 업데이트 했는지 확인한다.

   ```
   NAME                          DESIRED   CURRENT   READY   AGE
   nginx-deployment-1564180365   3         3         3       6s
   nginx-deployment-2035384211   0         0         0       36s
   ```

   `kubectl get pods`를 통해 새 파드만 확인 가능하다.

   ```
   NAME                                READY     STATUS    RESTARTS   AGE
   nginx-deployment-1564180365-khku8   1/1       Running   0          14s
   nginx-deployment-1564180365-nacti   1/1       Running   0          14s
   nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
   ```

**디플로이먼트 업데이트**

다음에(디플로이먼트를 처음 만든 후에는) 이러한 파드를 업데이트하려면 디플로이먼트의 파드 템플릿만 업데이트 하면 된다.

- 업데이트되는 동안 일정한 수의 파드만 중단되도록 보장한다.
- 의도한 파드 수보다 더 많이 생성되는 파드의 수를 제한한다.

> 디플로이먼트를 설정해 파드를 생성 → 이후엔 `.spec.tamplate`을 수정해 파드를 업데이트한다.

- `kubectl describe deployments`를 통해 디플로이먼트의 세부 정보를 가져온다.
  ```
  Name:                   nginx-deployment
  Namespace:              default
  CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
  Labels:                 app=nginx
  Annotations:            deployment.kubernetes.io/revision=2
  Selector:               app=nginx
  Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
  StrategyType:           RollingUpdate
  MinReadySeconds:        0
  RollingUpdateStrategy:  25% max unavailable, 25% max surge
  Pod Template:
    Labels:  app=nginx
     Containers:
      nginx:
        Image:        nginx:1.16.1
        Port:         80/TCP
        Environment:  <none>
        Mounts:       <none>
      Volumes:        <none>
    Conditions:
      Type           Status  Reason
      ----           ------  ------
      Available      True    MinimumReplicasAvailable
      Progressing    True    NewReplicaSetAvailable
    OldReplicaSets:  <none>
    NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
    Events:
      Type    Reason             Age   From                   Message
      ----    ------             ----  ----                   -------
      Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
      Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
      Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
      Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
      Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
      Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
      Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
  ```
  - availableReplicas 수 계산 시 종류 중인 파드는 포함하지 않는다.
    → 롤아웃 중에는 파드의 수가 예상보다 많을 수 있고, terminationGracePeriodSeconds가 만료될 때까지는 디플로이먼트가 소비하는 총 리소스가 replicas + maxSurge보다 많을 수 있다.

### 롤아웃(인-플라이트 다중 업데이트)

디플로이먼트의 역할은 위에서 봤듯이 항상 현재 파드 상태가 의도한 상태와 맞는 지 감시하는 것이다.

- `.spec.template`이 바뀌면, 새 레플리카셋을 만들고 트래픽을 옮겨가며 기존 레플리카셋을 스케일 다운한다. → 자연스러운 교체
- 롤링 업데이트 중 또 업데이트가 발생
  → 진행 중인 버전을 버리고, 새 버전 시작

### 레이블 셀렉터 업데이트

일반적으로 레이블 셀렉터를 업데이트하는 것을 권장하지 않고, 매우 주의해야한다.

- 샐렉터 추가 시 디플로이먼트의 spec에 있는 파드 템플릿 레이블도 업데이트 해야한다. → 유효성 검사 오휴 발생(새 셀렉터가 이전 셀렉터로 만든 레플리카셋과 파드를 선택하지 않고 모든 기존 레플리카셋은 고아가 된다.)
- 셀렉터 업데이트는 기존 셀렉터 키 값을 변경한다. → 추가와 같은 역할
- 셀렉터 삭제는 디플로이먼트 셀렉터의 기존 키를 삭제한다.(파드 템플릿 레이블 업데이트 불필요)

## 디플로이먼트 롤백

디플로이먼트의 롤아웃 기록은 시스템에 남아있어 언제든지 롤백이 가능하다.

- 디플로이먼트 수정 버전은 `spec.template`이 바뀔 때만 기록된다.
  (스케일링과 같은 건 기록하지 않는다.)
- 디플로이먼트 컨트롤러는 잘못된 롤아웃을 자동으로 중지하고, 새로운 레플리카의 스케일 업을 중지한다.
- 이미지 이름 오타 발생 시

  ```
  kubectl set image deployment/nginx-deployment nginx=nginx:1.161
  ...
  deployment.apps/nginx-deployment image updated
  ```

  `nginx:1.16.1` → `nginx:1.161`

  1. 롤아웃을 시작한다.

     ```
     kubectl rollout status deployment/nginx-deployment
     ...
     Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
     ```

  2. `kubectl get rs`를 통해 롤아웃 상태를 확인한다.

     ```
     NAME                          DESIRED   CURRENT   READY   AGE
     nginx-deployment-1564180365   3         3         3       25s
     nginx-deployment-2035384211   0         0         0       36s
     nginx-deployment-3066724191   1         1         0       6s
     ```

     새 레플리카가 1개 생성되었다.

  3. `kubectl get pods`를 통해 생성된 파드를 확인한다.

     ```
     NAME                                READY     STATUS             RESTARTS   AGE
     nginx-deployment-1564180365-70iae   1/1       Running            0          25s
     nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
     nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
     nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
     ```

### 디플로이먼트의 롤아웃 기록 확인

1. 디플로이먼트의 수정 사항을 확인한다.

   ```
   kubectl rollout history deployment/nginx-deployment
   ...
   deployments "nginx-deployment"
   REVISION    CHANGE-CAUSE
   1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml
   2           kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
   3           kubectl set image deployment/nginx-deployment nginx=nginx:1.161
   ```

   - CHANGE-CAUSE: 쿠버네티스가 직접 기록하는 버전이 바뀐 이유

2. 각 수정 버전의 세부 정보를 확인한다.

   ```
   deployments "nginx-deployment" revision 2
     Labels:       app=nginx
             pod-template-hash=1159050644
     Annotations:  kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
     Containers:
       nginx:
       Image:      nginx:1.16.1
       Port:       80/TCP
         QoS Tier:
           cpu:      BestEffort
           memory:   BestEffort
       Environment Variables:      <none>
     No volumes.
   ```

### 이전 수정 버전으로 롤백

1. 현재 롤아웃의 실행 취소 및 이전 수정 버전으로 롤백한다.

   ```
   kubectl rollout undo deployment/nginx-deployment
   kubectl rollout undo deployment/nginx-deployment --to-revision=2
   ...
   deployment.apps/nginx-deployment rolled back
   ```

   `--to-version` 옵션을 통해 구체적인 수정 버전을 지정가능하다.

   이전 버전으로 롤백되며 DeploymentRollback 이벤트가 디플로이먼트 컨트롤러에서 생성된다.

2. 롤백 성공 여부를 확인한다.

   ```
   kubectl get deployment nginx-deployment
   ...
   NAME               READY   UP-TO-DATE   AVAILABLE   AGE
   nginx-deployment   3/3     3            3           30m
   ```

3. `kubectl describe deployment nginx-deployment`를 통해 디플로이먼트의 설명을 확인한다.

   > 마지막에 디플로이먼트의 설명을 확인하는 것은 항상 하는 작업이라고 보면 될 듯

   ```
   Name:                   nginx-deployment
   Namespace:              default
   CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
   Labels:                 app=nginx
   Annotations:            deployment.kubernetes.io/revision=4
                           kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
   Selector:               app=nginx
   Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
   StrategyType:           RollingUpdate
   MinReadySeconds:        0
   RollingUpdateStrategy:  25% max unavailable, 25% max surge
   Pod Template:
     Labels:  app=nginx
     Containers:
       nginx:
       Image:        nginx:1.16.1
       Port:         80/TCP
       Host Port:    0/TCP
       Environment:  <none>
       Mounts:       <none>
     Volumes:        <none>
   Conditions:
     Type           Status  Reason
     ----           ------  ------
     Available      True    MinimumReplicasAvailable
     Progressing    True    NewReplicaSetAvailable
   OldReplicaSets:  <none>
   NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
   Events:
     Type    Reason              Age   From                   Message
     ----    ------              ----  ----                   -------
     Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
     Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
     Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set  nginx-deployment-75675f5897 to 2
     Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
     Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
     Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
     Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
     Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
     Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment "nginx-deployment" to revision 2
     Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
   ```

## 디플로이먼트 스케일링

명령어를 통해 디플로이먼트의 스케일을 확인하고 자동 스케일링 기능을 설정할 수 있다.

```
kubectl scale deployment/nginx-deployment --replicas=10
...
deployment.apps/nginx-deployment scaled
```

- Horizontal Pod Autoscaling(HPA): 파드의 CPU 사용률을 기준으로 디플로이먼트가 실행하는 파드 개수를 자동으로 늘리거나 줄이는 기능이다.
  ```
  kubectl autoscale deployment/nginx-deployment --min=10 --max=15 --cpu-percent=80
  ...
  deployment.apps/nginx-deployment scaled
  ```

### 비례적 스케일링(Proportional Scaling)

롤링 업데이트와 스케일링이 동시에 일어날 때, 여러 버전의 ReplicaSet이 동시에 존재하고 각 ReplicaSet의 현재 비율에 따라 균형 있게 조정한다.

- 예시
  10개의 레플리카(디플로이먼트 파드 수)가 10개이고 maxSurge=3(최대 13개까지 임시로 가능), maxUnavailable=2(최소 8개는 항상 있어야 함)일 때

  1. `kubectl get deploy`를 통해 디플로이먼트에 있는 10개의 레플리카를 확인한다.

     ```yaml
     NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
     nginx-deployment     10        10        10           10          50s
     ```

  2. 클러스터가 접근할 수 없는 이미지로 업데이트를 하고자 하는 경우에는 아래와 같은 문제가 발생한다.

     ```yaml
     kubectl set image deployment/nginx-deployment nginx=nginx:sometag
     ---
     deployment.apps/nginx-deployment image updated
     ```

  3. 이미지 업데이트는 nginx-deployment-1989198191로 새로운 롤아웃이 시작하지만, 위에서 언급한 maxUnavailable의 요구 사항으로 인해 차단된다. → `kubectl get res`로 확인

     ```
     NAME                          DESIRED   CURRENT   READY     AGE
     nginx-deployment-1989198191   5         5         0         9s
     nginx-deployment-618515232    8         8         8         1m
     ```

     새 이미지 버전이 5개 생성되었지만 ready가 0개로 이미지 불러오기 실패를 확인할 수 있다.

     → `maxUnavailable`에 의해 기존 파드를 더 이상 줄일 수 없고 롤아웃이 멈춘다.

  4. 이 때 오토스케일러는 부하가 늘었으니 파드를 15개로 늘리자고 명령을하고 디플로이먼트 컨트롤러는 이 명령에 따라 어디에 새 파드를 추가할 지 결정한다.

     이전 버전 ReplicaSet에 8개가 존재하고 새 버전 ReplicaSet이 5개가 존재할 때 각 61.5%, 38.5%

     → 이전 버전에 3개의 Pod를 추가하고, 새 버전에 2개의 Pod를 추가한다.

     `kubectl get deploy`로 결과를 확인해보면

     ```yaml
     NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
     nginx-deployment     15        18        7            8           7m
     ```

     `kubectl get rs`로 결과를 확인해보면

     ```yaml
     NAME                          DESIRED   CURRENT   READY     AGE
     nginx-deployment-1989198191   7         7         0         7m
     nginx-deployment-618515232    11        11        11        7m
     ```

## 디플로이먼트 롤아웃 일시 중지와 재개

디플로이먼트 롤링 업데이트를 일시 중지했다가 재개하는 기능이다.

- 쿠버네티스는 디플로이먼트 설정을 바꿀 경우, 자동으로 새 ReplicaSet을 만들어서 rolling update를 시작하게 되는데
  - 변경후 결과를 미리 검토하고 싶거나
  - 여러 변경 사항을 한꺼번에 적용하고 싶거나
    할 경우 pause/resume 기능을 통해 롤아웃을 원할 때 중지하고 재개할 수 있다.
- 일시중지된 디플로이먼트를 재개할 때까지 롤백할 수 없다.
- 예시

  1. 디플로이먼트의 상세 정보와 롤아웃 상태를 확인한다.

     ```yaml
     NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
     nginx     3         3         3            3           1m
     ```

     ```yaml
     NAME               DESIRED   CURRENT   READY     AGE
     nginx-2142116321   3         3         3         1m
     ```

  2. 명령어를 사용해 롤아웃을 일시중지한다.

     ```yaml
     kubectl rollout pause deployment/nginx-deployment
     ---
     deployment.apps/nginx-deployment paused
     ```

  3. 디플로이먼트의 이미지를 업데이트한다.

     ```yaml
     kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
     ---
     deployment.apps/nginx-deployment image updated
     ```

  4. 새로운 롤아웃이 시작되지 않는다.

     ```yaml
     kubectl rollout history deployment/nginx-deployment
     ---
     deployments "nginx"
     REVISION  CHANGE-CAUSE
     1   <none>
     ```

  5. 기존 레플리카셋이 변경되지 않았는지 롤아웃 상태를 확인한다.

     ```yaml
     NAME               DESIRED   CURRENT   READY     AGE
     nginx-2142116321   3         3         3         2m
     ```

  6. 일시중지된 상태에서 원하는만큼만 리소스를 업데이트한다.

     ```yaml
     kubectl set resources deployment/nginx-deployment -c=nginx --limits=cpu=200m,memory=512Mi
     ---
     deployment.apps/nginx-deployment resource requirements updated
     ```

  7. 디플로이먼트 롤아웃을 재개하고 새로운 레플리카셋이 새로운 업데이트를 제공하는지 확인한다.

     ```yaml
     kubectl rollout resume deployment/nginx-deployment
     ---
     deployment.apps/nginx-deployment resumed
     ```

  8. `kubectl get rs --watch`를 통해 롤아웃의 상태를 관찰한다.

     ```yaml
     NAME               DESIRED   CURRENT   READY     AGE
     nginx-2142116321   2         2         2         2m
     nginx-3926361531   2         2         0         6s
     nginx-3926361531   2         2         1         18s
     nginx-2142116321   1         2         2         2m
     nginx-2142116321   1         2         2         2m
     nginx-3926361531   3         2         1         18s
     nginx-3926361531   3         2         1         18s
     nginx-2142116321   1         1         1         2m
     nginx-3926361531   3         3         1         18s
     nginx-3926361531   3         3         2         19s
     nginx-2142116321   0         1         1         2m
     nginx-2142116321   0         1         1         2m
     nginx-2142116321   0         0         0         2m
     nginx-3926361531   3         3         3         20s
     ```

  9. 롤아웃 결과를 확인한다.

     ```yaml
     NAME               DESIRED   CURRENT   READY     AGE
     nginx-2142116321   0         0         0         2m
     nginx-3926361531   3         3         3         28s
     ```

## 디플로이먼트 상태

### 디플로이먼트 진행 중

- 디플로이먼트가 진행 중인 상태
  - 디플로이먼트로 새 레플리카셋을 생성
  - 디플로이먼트로 새로운 레플리카셋을 스케일 업
  - 디플로이먼트로 기존 레플리카셋을 스케일 다운
  - 새 파드가 준비되거아 이용할 수 있음
- 디플로이먼트가 진행 중이면 디플로이먼트의 `.status.conditions`에 컨디션을 추가한다.
  - `type: Progressing`
  - `status: “True”`
  - `reaseon: NewReplicaSetCreated` | `reaseon: FoundNewReplicaSet` | `reason: ReplicaSetUpdated`
    → kubectl rollout status를 통해 디플로이먼트의 진행상황을 모니터링한다.

### 디플로이먼트 완료

- 디플로이먼트가 완료 중인 상태
  - 요청한 모든 업데이트가 완료되었을 때
  - 모든 레플리카를 사용할 수 있을 때
  - 디플로이먼트에 대한 이전 복제본이 실행되고 있지 않을 때
- 디플로이먼트가 완료 상태이면 디플로이먼트의 `.status.conditions`에 컨디션을 추가한다.
  - `type: Progressing`
  - `status: “True”`
  - `reason" NewReplicaSetAvailable`
    이 컨디션은 새로운 롤아웃이 시작되기 전까지는 True 상태이다.
- kubectl rollout status를 사용해 디플로이먼트가 완료되었는지 확인한다.
  → 성공적으로 완료되면 종료 코드로 0이 반환된다.
  ```
  kubectl rollout status deployment/nginx-deployment
  ...
  Waiting for rollout to finish: 2 of 3 updated replicas are available...
  deployment "nginx-deployment" successfully rolled out
  ```

### 디플로이먼트 실패

디플로이먼트가 새 버전으로 롤링 업데이트 중일 때, 그 작업이 끝나지 않은 상태에서 또 다른 배포를 시도하면 실패한다. → 디플로이먼트는 항상 하나의 롤아웃 프로세스만 동시에 관리할 수 있다.

- 디플로이먼트 실패
  - 할당량 부족
  - 준비성 프로브의 실패
  - 이미지 풀 에러
  - 권한 부족
  - 범위 제한
  - 애플리케이션 런타임의 잘못된 구성
- `.sepc.progressDeadlineSeconds` 필드: 디플로이먼트 컨트롤러가 디플로이먼트의 진행이 정지됨에 따라 기다리는 시간의 제한 시간
  → 이 시간을 넘어서 기다리면 진행이 정지되었다고 판단한다.

  ```
  kubectl patch deployment/nginx-deployment -p '{"spec":{"progressDeadlineSeconds":600}}'
  ...
  deployment.apps/nginx-deployment patched

  ```

- 데드라인을 넘어서면 디플로이먼트 컨트롤러는 디플로이먼트의 `.status.conditions` 속성에 디플로이먼트 컨디션을 추가한다.
  - `type: Progressing`
  - `status: “False”`
  - `reason: ProgressDeadlineExceeded`
    → 쿠버네티스는 해당 컨디션 작성 이외에 정지된 디플로이먼트에 대한 조치를 취하지 않는다. 조치룰 위해선 오케스트레이터를 사용해야 한다.
- 예시
  설정한 타임아웃이 매우 낮거나, 다른 종료의 에러로 인해 디플로이먼트에 일시적인 에러가 발생할 수 있다.

  1. kubectl describe deployment nginx-deployment를 통해 디플로이먼트 설명을 확인한다.

     ```
     <...>
     Conditions:
       Type            Status  Reason
       ----            ------  ------
       Available       True    MinimumReplicasAvailable
       Progressing     True    ReplicaSetUpdated
       ReplicaFailure  True    FailedCreate
     <...>
     ```

  2. 디플로이먼트 진행 데드라인을 넘어서면 쿠버네티스는 진행 컨디션의 상태와 이유를 업데이트한다.

     ```
     Conditions:
       Type            Status  Reason
       ----            ------  ------
       Available       True    MinimumReplicasAvailable
       Progressing     False   ProgressDeadlineExceeded
       ReplicaFailure  True    FailedCreate
     ```

     리소스 부족으로 실패한 경우 아래와 같은 방법으로 해결한다.

     - 디플로이먼트 스케일 다운
     - 다른 컨트롤러 스케일 다운
     - 네임스페이스 확장

  3. 롤아웃이 성공적으로 완료되면 상태가 true로 업데이트 된다.

     ```
     Conditions:
       Type          Status  Reason
       ----          ------  ------
       Available     True    MinimumReplicasAvailable
       Progressing   True    NewReplicaSetAvailable
     ```

  4. `kubectl rollout status`로 롤아웃 상태를 확인하고 반한 코드를 바탕으로 실패를 감지할 수 있다.

### 실패한 디플로이먼트에서의 운영

완료된 디플로이먼트에 적용 가능한 모든 기능을 실패한 디플로이먼트에도 적용할 수 있다. → 스케일 업/다운, 롤백, 일시 중지 등

## 정책 초기화

`.spec.revisionHistoryLimit`을 통해 디플로이먼트에서 유지해야하는 이전 레플리카셋의 수를 명시할 수 있다. → 나머지는 가비지-수집의 대상이 된다.

- 이 필드가 0일 경우 기록을 전부 초기화하기 때문에, 롤백이 불가능해진다.
- 항상 새 버전 ReplicaSet을 생성한 다음 기존 ReplicaSet을 삭제하거나 스케일 다운한다.
  이 때문에 디플로이먼트가 완전한 상태에 도달하지 않으면 예전 ReplicaSet 삭제가 보류되고 실제로는 필드값보다 많은 ReplicaSet이 남을 수 있다. → 일종의 안전장치

## 카나리 디플로이먼트

일부 사용자 또는 일부 서버에서 디플로이먼트를 롤아웃하고 싶은 경우 카나리 패던에 따라 각 릴리스마다 하나씩 여러 디플로이먼트를 생성할 수 있다.

## 디플로이먼트 사양 작성

- 디플로이먼트를 정의할 때 반드시 포함해야하는 기본 필드
  - apiVersion: 디플로이먼트가 속한 API 그룹
  - kind: 리소스 유형 → Deployment
  - metadata: 이름, 라벨 등 기본 정보
  - spec: 실제 동작 정의
- **필수 구성 요소**
  | 항목 | 필드 | 설명 |
  | --------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------ |
  | **파드 템플릿** | `.spec.template` | 파드를 생성할 때 사용하는 템플릿. 실제 파드와 동일한 스키마이며 `apiVersion`, `kind`는 없음. |
  | **셀렉터** | `.spec.selector` | 디플로이먼트가 관리할 파드를 선택하는 **레이블 셀렉터**. → `.spec.template.metadata.labels` 와 반드시 일치해야 함. |
  → 여러 컨트롤러가 같은 셀렉터를 사용할 경우 충돌이 발생한다.
- **파드 템플릿 관련 설정**
  | 필드 | 설명 |
  | ----------------------------------- | ---------------------------------------------------------------- |
  | `.spec.template.metadata.labels` | 파드에 적용할 레이블 정의.다른 컨트롤러와 겹치지 않도록 해야 함. |
  | `.spec.template.spec.restartPolicy` | 파드의 재시작 정책. 디플로이먼트에서는 항상 `Always` 만 허용됨. |
- **레플리카**
  | 필드 | 설명 |
  | ------------------------------ | ------------------------------------------------------------------------------------------ |
  | `.spec.replicas` | 실행할 파드의 개수 지정 (기본값: 1). |
  | `kubectl scale deployment ...` | 수동으로 조정 가능하지만, `kubectl apply`로 매니페스트를 다시 적용하면 수동 설정이 덮어씀. |
  HPA(자동 스케일링)를 사용할 경우 `.spec.replicas`는 수동으로 설정하면 안된다.
- **셀렉터**
  | 필드 | 설명 |
  | ---------------- | ------------------------------------------------------------------------------------------- |
  | `.spec.selector` | 디플로이먼트가 관리할 파드를 선택하는 조건.`.spec.template.metadata.labels` 와 일치해야 함. |
  | 역할 | 디플로이먼트는 셀렉터를 기준으로 **필요 이상 파드 삭제**, **부족하면 새 파드 생성**. |
  - 한번 생성되면 변경 불가능
- **배포 전략**
  | 필드 | 설명 |
  | --------------------- | ------------------------------------ |
  | `.spec.strategy.type` | 디플로이먼트가 파드를 교체하는 방식. |
  - `Recreate`: 기존 파드를 전부 죽인 뒤 새로 생성
  - `RollingUpdate`(기본값): 순차적으로 교체 |
    | `.spec.strategy.rollingUpdate.maxUnavailable` | 롤링 업데이트 중 사용할 수 없는 **최대 파드 수**.숫자(예: 1) 또는 비율로 지정. 기본값 25%. |
    | `.spec.strategy.rollingUpdate.maxSurge` | 롤링 업데이트 중 **추가로 생성 가능한 최대 파드 수**.숫자 또는 비율. 기본값 25%. |
- **시간 관련 옵션**
  | 필드 | 설명 |
  | ------------------------------- | --------------------------------------------------------------------------- |
  | `.spec.progressDeadlineSeconds` | 디플로이먼트가 진행 중 “정체” 상태로 간주하기까지의 시간(초). 기본값 600초. |
  | `.spec.minReadySeconds` | 새 파드가 준비되었다고 간주되기 전에 기다릴 최소 시간(초). 기본값 0. |
- **파드 종료 관련**
  | 필드 | 설명 |
  | ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
  | `.status.terminatingReplicas` | 종료 중(Terminating) 파드의 개수를 추적. |
  | 파드가 완전히 삭제되기 전까지 리소스를 점유하므로 일시적으로 `.spec.replicas` 수보다 많아질 수 있음. |
  | 활성화 방법 | API 서버 및 컨트롤러 매니저에 `DeploymentReplicaSetTerminatingReplicas` 기능 게이트 활성화 필요. |
  - API 서버와 컨트롤러 매니저에 `DeploymentReplicaSetTerminatingReplicas` 기능을 활성화
- **수정 버전 기록 제한**
  | 필드 | 설명 |
  | ---------------------------- | ---------------------------------------------------------------- |
  | `.spec.revisionHistoryLimit` | 과거 ReplicaSet(수정 버전)을 몇 개까지 유지할지 지정. 기본값 10. |
- **일시중지**
  | 필드 | 설명 |
  | -------------- | ------------------------------------------------------------------------ |
  | `.spec.paused` | 디플로이먼트를 **일시 중지(true)** 또는 **재개(false)** 할 수 있는 필드. |
