레플리카 파드 집합의 실행을 항상 안정적으로 유지하기 위해 사용하는 리소스이다. → 파드 개수에 대한 가용성을 보증

## 레플리카셋의 작동 방식

| 구성 요소    | 설명                                           |
| ------------ | ---------------------------------------------- |
| **selector** | 어떤 파드를 관리할지 결정하는 조건 (라벨 기반) |
| **replicas** | 유지해야 하는 파드 개수                        |
| **template** | 새로 파드를 만들어야 할 때 쓸 설계도           |

- 레플리카셋은 위 정보를 바탕으로 파드의 개수를 항상 맞춘다.
- 파드와의 연결
  각 파드의 `metadata.OwnerReferences` 필드에 소유자 정보가 들어간다.
  → 레플리카셋은 이 링크를 통해 자신이 관리중인 파드를 추적한다.
- label selector를 통해 관리 대상 파드를 찾는다.
  만약 파드가 `OwnerReferences`가 없고 다른 컨트롤러에 속해 있지 않으며, 레플리카셋의 셀렉터와 라벨이 일치하면 관리 대상에 포함된다.

## 레플리카셋을 사용하는 시기

일반적으로는 사용하지 않지만 (→ 디플로이먼트가 자동으로 관리하기 때문에) 특정 상황에서 사용한다.

- 업데이트 기능이 전혀 필요없는 단순한 워크로드
- 커스텀한 업데이트 방식을 구현해야 할 때

> ### Deployment와 ReplicatSet의 차이점

| 구분                    | **ReplicaSet**                            | **Deployment**                                        |
| ----------------------- | ----------------------------------------- | ----------------------------------------------------- |
| **역할**                | 파드 개수를 유지                          | ReplicaSet을 관리하면서 파드의 배포·업데이트까지 담당 |
| **업데이트 기능**       | ❌ 없음 → 수동으로 삭제·생성해야 함       | ✅ 롤링 업데이트, 롤백 등 자동 제공                   |
| **롤백(되돌리기)**      | ❌ 불가능                                 | ✅ 이전 버전으로 손쉽게 복원 가능                     |
| **버전 관리(Revision)** | ❌ 없음                                   | ✅ 각 업데이트 버전 자동 기록                         |
| **사용 편의성**         | 저수준(직접 제어 필요)                    | 고수준(자동화, 선언적 관리)                           |
| **추천 사용 상황**      | 커스텀 업데이트 로직이 필요한 특수한 경우 | 대부분의 일반 애플리케이션 배포 시 사용               |

## 예시

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: frontend
  labels:
    app: guestbook
    tier: frontend
spec:
  # 케이스에 따라 레플리카를 수정한다.
  replicas: 3
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
        - name: php-redis
          image: gcr.io/google_samples/gb-frontend:v3
```

이 .yaml 파일을 저장해 쿠버네티스 클러스터에 적용하면 정의된 레플리카셋이 생성되고 레플리카셋이 관리하는 파드가 생성된다.

```
kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
```

현재 배포된 레플리카셋을 확인하고 생성된 파드를 확인한다.

```
kubectl get rs
...
NAME       DESIRED   CURRENT   READY   AGE
frontend   3         3         3       6s
```

`kubectl describe rs/frontend`를 통해 레플리카셋의 상태를 확인한다.

```
Name:         frontend
Namespace:    default
Selector:     tier=frontend
Labels:       app=guestbook
              tier=frontend
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {"apiVersion":"apps/v1","kind":"ReplicaSet","metadata":{"annotations":{},"labels":{"app":"guestbook","tier":"frontend"},"name":"frontend",...
Replicas:     3 current / 3 desired
Pods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:  tier=frontend
  Containers:
   php-redis:
    Image:        gcr.io/google_samples/gb-frontend:v3
    Port:         <none>
    Host Port:    <none>
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Events:
  Type    Reason            Age   From                   Message
  ----    ------            ----  ----                   -------
  Normal  SuccessfulCreate  117s  replicaset-controller  Created pod: frontend-wtsmm
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-b2zdv
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-vcmts
```

`kubectl get pods`를 통해 마지막으로 파드가 올라왔는지 확인한다.

```
NAME             READY   STATUS    RESTARTS   AGE
frontend-b2zdv   1/1     Running   0          6m36s
frontend-vcmts   1/1     Running   0          6m36s
frontend-wtsmm   1/1     Running   0          6m36s
```

파드들의 소유자 참조 정보가 해당 레플리카셋으로 설정되어 있는지 확인하기위해 실행 중인 파드 중 하나의 yaml을 `kubectl get pods frontend-b2zdv -o yaml`를 통해 확인한다.

```yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: "2020-02-12T07:06:16Z"
  generateName: frontend-
  labels:
    tier: frontend
  name: frontend-b2zdv
  namespace: default
  ownerReferences:
    - apiVersion: apps/v1
      blockOwnerDeletion: true
      controller: true
      kind: ReplicaSet
      name: frontend
      uid: f391f6db-bb9b-4c09-ae74-6a1f77f3d5cf
```

`OwnerReferences` 필드에 설정되어있는 레플리카셋의 정보가 나온다.

## 템플릿을 사용하지 않는 파드의 획득

사용자가 직접 `kubectl apply -f pod.yaml`를 통해 단독 파드를 생성할 때, 이 파드의 레이블이 ReplicaSet의 셀렉터(matchLabels)와 같으면 문제가 발생한다.

- 왜?
  ReplicaSet은 레이블 셀렉터를 통해서 관리할 파드를 탐색하는데 단독 파드도 자신의 소유로 추가하는 문제가 발생한다.
- 예

  1. 단독 파드를 생성한다.

     ```yaml
     # pod1, pod2
     metadata:
       name: pod1
       labels:
         tier: frontend
     ```

  2. ReplicaSet을 생성한다.

     ```yaml
     kubectl apply -f frontend-replicaset.yaml
     ```

     이 ReplicaSet의 설정이 `selector.matchLabels.tier:frontend`일 경우 위에 pod1과 pod2를 소유자로 등록한다.

  3. 여기서 ReplicaSet이 필요 수량보다 많다고 판단하면 Pod1, Pod2를 즉시 종료한다.

     → 직접 만들지 않은 파드까지 관리

## 레플리카셋 매니페스트 작성하기

- 레플리카셋을 정의할 때 반드시 포함해야하는 기본 필드
  - apiVersion: 디플로이먼트가 속한 API 그룹
  - kind: 리소스 유형 → ReplicaSet
  - metadata: 이름, 라벨 등 기본 정보
  - spec: 실제 동작 정의

### 파드 템플릿

.spec.template에 의해 정의되며 파드를 생성할때 사용되는 template으로 실제 파드와 동일한 형태로 구성된다.

- 파드 템블릿의 레이블은 다른 컨트롤러의 셀렉터와 겹쳐서는 안된다.
- `.spec.template.spec.restartPolicy`는 항상 Always여야 한다.

### 파드 셀렉터

`.spec.selector`에 정의되며 소유될 가능성이 있는 파드를 식별하는 역할이다.

- `.spec.template.metadata.labels`는 `spec.selector`와 일치해야 한다. → API에 의해 거부
- 예
  ```yaml
  matchLabels:
  	tier: frontend
  ```

→ 셀렉터가 같아도 템플릿이 다르면 레플리카셋은 서로의 파드를 무시한다. 셀렉터와 템플릿이 모두 같을 경우 ReplicaSet끼리 충돌할 수 있다.

### 레플리카

`.spec.replicas`를 설정해서 동시에 동작하는 파드의 수를 지정할 수 있다.

→ 레플리카셋은 이 값에 맞춰서 파드를 생성 및 삭제한다.

## 레플리카셋 작업

### 레플리카셋과 해당 파드 삭제

`kubectl delete`을 통해 레플리카셋 및 모든 파드를 삭제할 수 있다.

- 기본적으로 가비지 컬렉터가 작동해 ReplicaSet이 소유한 모든 파드를 자동으로 같이 삭제한다.
- REST API에서 직접 호출도 가능하다.
  ```
  propagationPolicy: Foreground
  ```

### 레플리카셋만 삭제하기

`kubectl delete rs <replicaset-name> --cascade-orphan`ReplicaSet만 삭제하고 파드는 그대로 둘 수 도 있다.

- 이후 새 ReplicaSet을 만들고 matchLabels를 동일하게 설정해 파드를 관리할 수 있다.
  → 기존 파드를 새 템플릿으로 갱신하지는 않는다.(업데이트는 디플로이먼트로 수행)

### 레플리카셋엣 파드 격리

레이블을 변경하면 레플리카셋에서 파드를 제거할 수 있다.

- 디버깅과 데이터 복구를 위해 사용된다.
- 자동으로 다른 파드로 교체된다.

### 레플리카셋의 스케일링

`.spec.replicas` 필드를 수정해서 스케일 업/다운을 수행할 수 있다.

- 스케일 다운 시 삭제 우선순위가 정의되어 있다.
  1. Pending 상태(스케줄링 불가능)
  2. `controller.kubernetes.io/pod-delection-cost` 값이 낮은 Pod
  3. 레플리카 수가 많은 노드의 파드
  4. 최근 생성된 파드

### 파드 삭제 비용

파드별 삭제 우선순위를 어노테이션을 통해 직접 정의할 수 있다.

```yaml
metadata:
  annotations:
    controller.kubernetes.io/pod-deletion-cost: "10"
```

- 낮은 값일수록 먼저 삭제된다.

### **레플리카셋을 Horizontal Pod Autoscaler 대상으로 설정**

레플리카셋은 Horizontal Pod Autoscaler(HPA)의 대상이 될 수 있다.

- `kubectl autoscale rs frontend --max=10 --min=3 --cpu-percent=50` 명령어도 사용 가능하다.
- 예
  ```yaml
  apiVersion: autoscaling/v1
  kind: HorizontalPodAutoscaler
  metadata:
    name: frontend-scaler
  spec:
    scaleTargetRef:
      kind: ReplicaSet
      name: frontend
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 50
  ```
  - CPU 사용률이 50%가 넘거나
  - 3개 이하로는 줄지 않고, 10개 이상으로는 늘지 않는다.

## 레플리카셋의 대안

| 대안                          | 설명                                                   | 사용 시점 / 목적 |
| ----------------------------- | ------------------------------------------------------ | ---------------- |
| **디플로이먼트 (Deployment)** | - ReplicaSet을 **자동으로 생성·관리**하는 상위 리소스. |

- 파드의 **선언적 업데이트**와 **롤링 업데이트** 지원.
- 사용자가 직접 ReplicaSet을 관리할 필요 없음. | **가장 권장되는 방식.**애플리케이션을 배포·업데이트할 때 사용. |
  | **기본 파드 (Pod)** | - 사용자가 직접 파드 생성 가능하지만, ReplicaSet처럼 파드가 죽으면 **자동 복구 안 됨.**
- ReplicaSet은 파드가 죽으면 자동으로 새 파드를 생성. | 단순 테스트나 1회성 실행용으로만 사용.운영 환경에서는 **ReplicaSet 이상 사용 권장.** |
  | **잡 (Job)** | - **작업이 끝나면 자동 종료되는 파드**를 관리.
- 일시적인 배치 작업용.
- 완료된 후에는 다시 실행되지 않음. | **배치 잡(Batch Job)** 같은 **단기 실행 파드** 관리에 사용. |
  | **데몬셋 (DaemonSet)** | - **모든 노드에 1개씩 파드**를 자동으로 띄움.
- 각 노드에서 항상 실행되어야 하는 시스템 파드 관리.
- 예: 로그 수집기, 노드 모니터링 에이전트 등. | **노드 단위 파드(시스템 레벨 서비스)** 실행 시 사용. |
  | **레플리케이션 컨트롤러 (ReplicationController)** | - ReplicaSet의 **이전 세대 버전.**-
  거의 같은 역할을 하지만 **레이블 셀렉터(matchExpressions)** 지원이 없음. | 현재는 **ReplicaSet으로 대체됨.** (RC는 구형 방식) |
