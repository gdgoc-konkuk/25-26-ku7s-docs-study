## 잡: Job

1. **잡(Job)이란?**

- 반드시 끝내야 하는 일회성 업무를 정의한 기획서와 같다.
  - 목표가 달성될 때까지 파드를 계속 생성하고, 만약 중간에 파드 실패시, 즉시 새 파드를 투입해서라도 목표를 완수하려고 노력한다.

---

2. **예시 Job 실행하기**

- 파이(π)의 2000자리까지 계산하는 `perl` 이미지를 사용한 잡을 정의해보자.

  ```yaml
  apiVersion: batch/v1
  kind: Job
  metadata:
  name: pi
  spec:
  template:
      spec:
      containers:
      - name: pi
          image: perl:5.34.0
          command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      # 컨테이너가 실패하면 파드 자체를 재시작하지 말고,
      # 잡 컨트롤러가 새로운 파드를 만들도록 한다.
      restartPolicy: Never
  # 이 임무는 최대 4번까지 실패할 수 있다.
  # 4번 실패하면 "이 프로젝트는 실패"로 간주
  backoffLimit: 4
  ```

- `kubectl describe job pi` 명령을 통해 잡의 상태(시작 시간, 완료 시간, 파드 상태 등)를 확인할 수 있으며, `kubectl logs [파드이름]`으로 실제 계산 결과(파이 값)를 볼 수 있다.

---

3. **잡 사양 작성하기**

- 다른 쿠버네티스 설정과 같이 `apiVerson, kind, metadata`필드가 필요하다.
  - 또한 데몬셋과 같이 `spec`센션이 필요하다.
    - `.spec.template`필드가 필수다.
    - 이 템플릿은 잡이 생성할 파드의 설계도를 정의한다.
- 잡의 파드 템플릿은 `RestartPolicy` (재시작 정책)가 `Never` 또는 `OnFailure`로만 설정되어야 한다.
  - `Always` (항상 재시작)는 허용되지 않는다.
  - 이는 잡이 '언젠가 끝나는' 작업임을 보장하기 위함이다.
- `.spec.selector` (파드 셀렉터)는 보통 자동으로 생성되므로 대부분 지정할 필요가 없다.

---

4. **잡에 대한 병렬 실행**

- 잡으로 실행하기에 적합한 작업 유형은 크게 3가지가 있다.
  1. 비-병렬(Non-parallel) 잡
     - 일반적으로 파드가 실패하지 않은 한, 하나의 파드만 시작
     - 파드가 성공적으로 종료하자마자 즉시 잡이 완료
     - `.spec.completions`와 `.spec.parallelism`을 모두 설정하지 않거나 1로 설정
  2. 고정적(fixed)인 완료 횟수를 가진 병렬 잡
     - `.spec.completions` 에 0이 아닌 양수 값을 지정한다.
     - 병렬이라고 생각하면 된다.
     - `Indexed`를 사용해 실행될 위치를 지정할 수도 있따.
  3. 작업 큐(queue)가 있는 병렬 잡
     - `.spec.completions`는 설정하지 않고,  `.spec.parallelism`을 설정
     - .spec.parallelism: 5 → 5개의 파드가 동시에 실행되며, 파드들은 외부 작업 큐 등과 통신하여 작업을 나눠 처리

---

5. **병렬 처리 제어하기**

- `.spec.parallelism`은 동시에 실행될 수 있는 파드의 수를 제어
- `completions`(총 완료 횟수)가 `parallelism`(동시 실행 수)보다 크다면, 잡 컨트롤러는 `parallelism` 수만큼 파드를 실행
  - 성공적으로 완료되면 다음 파드를 실행하는 식으로 총  `completions` 횟수를 맞춘다.
- '고정 완료 횟수(분업 TF)' 방식에서 "총 10개 구역 조사"(`completions: 10`)가 목표일 때, "동시 근무 인원은 3명"(`parallelism: 3`)으로 설정하면, 3명씩 조를 짜서 순차적으로(3명 -> 3명 -> 3명 -> 1명) 작업을 완료

---

6. **완료 모드(Indexed, NonIndexed)**

- 고정적(fixed)인 완료 횟수를 가진 병렬 잡에서 일을 주는 방식을 말한다.
  - NonIndexed: 그냥 암거나 채워.
  - Indexed: 파드들이 환경 변수로 자신의 인덱스를 알 게 되어 각자의 역할을 담당하도록
    - `Indexed` 모드는 각 파드가 0에서 `.spec.completions-1`까지의 고유한 **완료 인덱스**를 가진다.
    - 이 인덱스는 파드 어노테이션(`batch.kubernetes.io/job-completion-index`), 호스트네임, 또는 환경 변수(`JOB_COMPLETION_INDEX`)로 전달되어, 각 파드가 자신이 처리해야 할 작업 단위를 식별하는 데 사용된다.

---

7. **파드와 컨테이너 장애 처리하기?**

- 장애 상황은 크게 2가지로 나뉜다.
  - 컨테이너 실패, 그리고 파드 실패이다.
  - 컨테이너 실패 시 restartPolicy에 따라 상황이 달라진다.
    - 이전에 재시작 정책은 OnFailure, Never 중에 선택되어야 된다고 말했다.
    - OnFailure → 어? 오류났네? → 정해진 행동 지침에 따라 재시작
    - Never → 어? 오류났네? → 그대로 짐싸서 퇴근 → 파드 실패 발생
  - 파드 실패 시
    - 사실 파드 실패도 2가지 상황에 의해 발생할 수 있다.
    - 해당 파드만 특별히 고장난 걸수도 있고, 컨테이너가 실패해서 걍 샷다운 해버린 걸수도 있다.
    - 이때는 Kubelet 수준에서 해결하는 것이 아닌 잡 컨트롤러가 개입해서 새로운 파드를 만들어 적절한 위치에 배치하도록 한다.

---

8. **파드 백오프(backoff) 실패 정책**

- `.spec.backoffLimit`은 잡을 '실패'로 처리하기 전까지 재시도할 횟수를 한다. (기본값 6)
- 파드가 실패하면 잡 컨트롤러는 지수적으로 증가하는 백오프 지연(10초, 20초, 40초...)을 적용한 후 새 파드를 생성한다.
- 이 실패 횟수가 `backoffLimit`에 도달하면 잡은 실패로 처리되고 더 이상 파드를 생성하지 않는다.

---

9. **잡의 종료와 정리**

- 잡이 완료되어도 파드와 잡 객체는 자동으로 삭제되지 않으며, 이는 로그와 상태를 확인하기 위함이다.
- 사용자가 `kubectl delete`로 수동 삭제해야 된다.
- `.spec.activeDeadlineSeconds` 를 설정하면 지정된 시간(초)이 지나도 잡이 완료되지 않을 경우, 잡을 `Failed`로 처리하고 실행 중인 파드를 모두 종료시킨다.

---

10. **완료된 잡을 자동으로 정리(TTL)**

- `.spec.ttlSecondsAfterFinished` 필드를 사용하면, 잡이 완료(Complete 또는 Failed)된 후 지정된 시간(초)이 지나면 TTL 컨트롤러가 잡과 관련 파드(종속 객체)를 자동으로 삭제해 준다.

---

11. **잡 패턴**

- “10000개의 신제품 샘플을 포장해서 발송”하는 프로젝트(잡)이 있다고 하자.
  - 여기서 작업 항목(W)는 10000개의 개별 택배 상자이다.
  - 각 직원(파드)는 포장 및 발송 작업을 하는 주체이다.
- 그런데 10000개의 상자를 포장하는 방법은 여러 가지다.
  - 각 상자(작업 항목)마다 별개의 프로젝트(잡) 1개씩 만들기가 될 수도 있고
  - 단일 프로젝트(잡)로 10000개를 처리할 수도 있다.
    - `샘플 발송`이라는 큰 프로젝트(잡) 1개로 10000개를 모두 처리하는 것이 전자의 방법보다는 더 효율적이다.
- 하지만, 단일 프로젝트를 운영할 때도 방식이 나뉜다.
  - 직원(파드) 10000명을 뽑아 각 직원마다 1개씩 상자를 포장하게끔 할 수도 있고, 직원 10명을 뽑아 각 직원 마다 1000개씩 포장하게끔 할 수도 있다.
  - 우리는 병렬처리를 하기 위해 후자의 방법을 사용할 것이다.
- 다만, 이 후자의 방법도 다른 방법이 존재한다.
  - Queue 방식: 중앙 창고(작업 큐)에 10000개 상자를 쌓아두고, 10명의 직원이 와서 각자 상자를 하나씩 가져가 포장하고, 다 하면 다시 창고에 와서 앞에 놓인 상자를 가져가는 것이 있을 수 있고
  - Indexed 방식: 각자 직원들에게 부여된 상자 번호를 말해주고, 각각 작업을 처리하게끔 할 수도 있다.
- 공식문서에서는 여러 트레이드 오프에 대해서 이야기를 해준다.
  - **트레이드오프 1:** 작업 항목이 많을 경우, (항목마다 잡을 만드는 것보다) **단일 잡 오브젝트**로 처리하는 것이 오버헤드가 적어 더 적합합니다.
  - **트레이드오프 2:** (기존 코드 수정이 필요 없는) '작업 항목 수만큼 파드 생성' 방식보다, (작업 항목이 많을 때) '하나의 파드가 여러 항목을 처리'하는 것이 더 적합합니다.

---

12. **고급 사용법**

- **일시 중지(`.spec.suspend` )**
  - `.spec.suspend`를 `true`로 설정하면 잡이 일시 중지되고, 실행 중인 파드들은 SIGTERM 신호를 받고 종료된다.
  - `false`로 바꾸면 잡이 재개되며, `startTime`과  `activeDeadlineSeconds`가 재설정된다.
- **가변적 스케줄링 지시**
  - 일시 중지 후 다시 재개할 때, 스케줄링 명세를 변경할 수 있다.
  - 커스텀 큐 컨트롤러가 파드 배치에 영향을 줄 수 있도록, `nodeAffinity`, `nodeSelector`, `tolerations`, `labels`, `annotations` 같은 **파드 템플릿 필드를 업데이트**할 수 있다.
- **자신의 파드 셀렉터를 지정하기**
  - 일반적으로 `.spec.selector`는 절대 지정해서는 안 된다.
  - 시스템이 자동으로 고유한 값을 생성하여 잡이 서로의 파드를 훔쳐가지 못하게 막는다.
  - 하지만 정말 잡을 삭제할 일이 있다면 아래와 같이 설정할 수 있다.
    - `kubectl delete job/old --cascade=orphan` : "A 매니저만 해고하고, 직원들(파드)은 **'고아'로 남겨둔 채** 계속 일하게 해!"
  - 이 기능은 아래와 같은 특징을 지닌다.
    - **위험성:** 만약 고유하지 않은 셀렉터를 지정하면, 다른 잡의 파드를 삭제하거나, 남의 파드를 자기가 완료한 것으로 착각하는 등 예측 불가능한 오류가 발생한다.
    - **유일한 사용 사례:** 위 비유처럼 `cascade=orphan`으로 잡을 삭제하여 파드들을 남겨둔 상태에서, 새 잡이 이 파드들을 '입양'하여 작업을 이어가도록 할 때 사용한다.
    - 이때는 시스템이 자동 생성하는 셀렉터와 충돌이 나므로, `manualSelector: true`를 명시하여 "내가 일부러 이렇게 하는 것이니 허용해달라"고 알려야 한다.

---

13. **파드 실패 정책**

- `.spec.backoffLimit`보다 더 세밀하게 실패를 제어하는 기능이다. (반드시 `restartPolicy: Never`여야 함)

  ```yaml
  apiVersion: batch/v1
  kind: Job
  metadata:
  name: job-pod-failure-policy-example
  spec:
  ...
  podFailurePolicy:
      rules:
      - action: FailJob            # 3. 잡 전체를 즉시 실패 처리해버림,
      onExitCodes:               # 컨테이너의 특정 종료 코드를 감지
          containerName: main      # 1. 이 컨테이너가
          operator: In
          values: [42]             # 2. 이 값으로 종료되면
      - action: Ignore             # [Ignore, FailJob, Count가 존재]
      onPodConditions:
      - type: DisruptionTarget   # 파드의 중단을 나타냄

  ```

---

14. **종료자(finalizers)를 이용한 잡 추적**

- 잡 컨트롤러는 파드를 생성할 때 `batch.kubernetes.io/job-tracking`이라는 종료자(Finalizer)를 파드에 추가
  - 파드가 삭제되려고 할 때, 이 종료자 때문에 즉시 삭제되지 않는다.
- 잡 컨트롤러는 해당 파드의 상태(성공/실패)를 잡의 `status`에 **정확히 반영(카운트)한 후**, 종료자를 제거한다..
  - 종료자가 제거되면 파드는 비로소 API 서버에서 완전히 삭제된다.

---

15. **대안**

- **베어 파드**
  - 노드 실패 시 파드가 종료되고 재시작되지 않는다.
  - 잡은 파드 실패 시 새 파드를 생성하여 작업을 보장하므로, 단일 파드라도 잡을 사용하는 것이 좋다.
- **레플리케이션 컨트롤러**
  - 레플리케이션 컨트롤러는 **종료하지 않을 파드**(예: 웹 서버)를 관리
  - 잡은 **종료될 것으로 예상되는 파드**(예: 배치 작업)를 관리
